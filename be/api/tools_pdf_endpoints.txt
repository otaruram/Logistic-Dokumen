# Add these endpoints to the end of be/api/tools.py after the compress endpoint

# ====== NEW PDF TOOLS: MERGE, SPLIT, CONVERT, WATERMARK, UNLOCK ======

@router.post("/pdf/merge")
async def merge_pdfs_endpoint(
    background_tasks: BackgroundTasks,
    files: List[UploadFile] = File(...),
    user_id: str = Depends(get_current_user)
):
    """Merge multiple PDFs into one"""
    MAX_FILE_SIZE = 10 * 1024 * 1024
    temp_files = []
    
    try:
        if len(files) < 2:
            raise HTTPException(status_code=400, detail="Minimum 2 PDF files required")
        
        # Save uploaded files to temp
        for file in files:
            if file.content_type != "application/pdf":
                raise HTTPException(status_code=400, detail=f"{file.filename} is not a PDF")
            
            content = await file.read()
            if len(content) > MAX_FILE_SIZE:
                raise HTTPException(status_code=400, detail=f"{file.filename} exceeds 10MB")
            
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
            temp_file.write(content)
            temp_file.close()
            temp_files.append(temp_file.name)
        
        # Merge PDFs
        output_path = PdfToolbox.merge_pdfs(temp_files)
        if not output_path:
            raise HTTPException(status_code=500, detail="Failed to merge PDFs")
        
        # Cleanup
        for temp_file in temp_files:
            background_tasks.add_task(PdfToolbox.cleanup_files, temp_file)
        background_tasks.add_task(PdfToolbox.cleanup_files, output_path)
        
        # Log activity
        if user_id:
            user_id_int = int(user_id)
            await log_activity(user_id_int, "pdf_tools", "merge", {"file_count": len(files)})
        
        return FileResponse(
            path=output_path,
            media_type="application/pdf",
            filename="merged.pdf"
        )
        
    except Exception as e:
        for temp_file in temp_files:
            PdfToolbox.cleanup_files(temp_file)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/pdf/split")
async def split_pdf_endpoint(
    background_tasks: BackgroundTasks,
    file: UploadFile = File(...),
    start_page: int = Form(1),
    end_page: int = Form(5),
    user_id: str = Depends(get_current_user)
):
    """Split PDF - extract specific pages (1-indexed for user, 0-indexed internally)"""
    MAX_FILE_SIZE = 10 * 1024 * 1024
    temp_input = None
    
    try:
        if file.content_type != "application/pdf":
            raise HTTPException(status_code=400, detail="Only PDF files allowed")
        
        content = await file.read()
        if len(content) > MAX_FILE_SIZE:
            raise HTTPException(status_code=400, detail="File exceeds 10MB")
        
        # Save input to temp
        temp_input = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
        temp_input.write(content)
        temp_input.close()
        
        # Convert to 0-indexed
        output_path = PdfToolbox.split_pdf(temp_input.name, start_page - 1, end_page)
        if not output_path:
            raise HTTPException(status_code=400, detail="Invalid page range")
        
        # Cleanup
        background_tasks.add_task(PdfToolbox.cleanup_files, temp_input.name)
        background_tasks.add_task(PdfToolbox.cleanup_files, output_path)
        
        # Log activity
        if user_id:
            user_id_int = int(user_id)
            await log_activity(user_id_int, "pdf_tools", "split", {"pages": f"{start_page}-{end_page}"})
        
        return FileResponse(
            path=output_path,
            media_type="application/pdf",
            filename=f"split_p{start_page}-{end_page}.pdf"
        )
        
    except Exception as e:
        if temp_input:
            PdfToolbox.cleanup_files(temp_input.name)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/pdf/to-images")
async def pdf_to_images_endpoint(
    background_tasks: BackgroundTasks,
    file: UploadFile = File(...),
    max_pages: int = Form(10),
    user_id: str = Depends(get_current_user)
):
    """Convert PDF to JPG images (max 10 pages to prevent server overload)"""
    MAX_FILE_SIZE = 10 * 1024 * 1024
    temp_input = None
    image_paths = []
    
    try:
        if file.content_type != "application/pdf":
            raise HTTPException(status_code=400, detail="Only PDF files allowed")
        
        content = await file.read()
        if len(content) > MAX_FILE_SIZE:
            raise HTTPException(status_code=400, detail="File exceeds 10MB")
        
        if max_pages > 20:
            raise HTTPException(status_code=400, detail="Maximum 20 pages allowed")
        
        # Save input to temp
        temp_input = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
        temp_input.write(content)
        temp_input.close()
        
        # Convert to images
        image_paths = PdfToolbox.pdf_to_images(temp_input.name, max_pages)
        if not image_paths:
            raise HTTPException(status_code=500, detail="Failed to convert PDF")
        
        # Create ZIP file
        zip_path = tempfile.NamedTemporaryFile(delete=False, suffix=".zip")
        with zipfile.ZipFile(zip_path.name, 'w') as zipf:
            for i, img_path in enumerate(image_paths):
                zipf.write(img_path, f"page_{i+1}.jpg")
        zip_path.close()
        
        # Cleanup
        background_tasks.add_task(PdfToolbox.cleanup_files, temp_input.name)
        background_tasks.add_task(PdfToolbox.cleanup_files, image_paths)
        background_tasks.add_task(PdfToolbox.cleanup_files, zip_path.name)
        
        # Log activity
        if user_id:
            user_id_int = int(user_id)
            await log_activity(user_id_int, "pdf_tools", "to_images", {"page_count": len(image_paths)})
        
        return FileResponse(
            path=zip_path.name,
            media_type="application/zip",
            filename="pdf_images.zip"
        )
        
    except Exception as e:
        if temp_input:
            PdfToolbox.cleanup_files(temp_input.name)
        if image_paths:
            PdfToolbox.cleanup_files(image_paths)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/pdf/watermark")
async def add_watermark_endpoint(
    background_tasks: BackgroundTasks,
    file: UploadFile = File(...),
    watermark_text: str = Form("CONFIDENTIAL"),
    user_id: str = Depends(get_current_user)
):
    """Add watermark text to PDF"""
    MAX_FILE_SIZE = 10 * 1024 * 1024
    temp_input = None
    
    try:
        if file.content_type != "application/pdf":
            raise HTTPException(status_code=400, detail="Only PDF files allowed")
        
        content = await file.read()
        if len(content) > MAX_FILE_SIZE:
            raise HTTPException(status_code=400, detail="File exceeds 10MB")
        
        # Save input to temp
        temp_input = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
        temp_input.write(content)
        temp_input.close()
        
        # Add watermark
        output_path = PdfToolbox.add_watermark(temp_input.name, watermark_text)
        if not output_path:
            raise HTTPException(status_code=500, detail="Failed to add watermark")
        
        # Cleanup
        background_tasks.add_task(PdfToolbox.cleanup_files, temp_input.name)
        background_tasks.add_task(PdfToolbox.cleanup_files, output_path)
        
        # Log activity
        if user_id:
            user_id_int = int(user_id)
            await log_activity(user_id_int, "pdf_tools", "watermark", {"text": watermark_text})
        
        return FileResponse(
            path=output_path,
            media_type="application/pdf",
            filename="watermarked.pdf"
        )
        
    except Exception as e:
        if temp_input:
            PdfToolbox.cleanup_files(temp_input.name)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/pdf/unlock")
async def unlock_pdf_endpoint(
    background_tasks: BackgroundTasks,
    file: UploadFile = File(...),
    password: str = Form(...),
    user_id: str = Depends(get_current_user)
):
    """Remove password from PDF"""
    MAX_FILE_SIZE = 10 * 1024 * 1024
    temp_input = None
    
    try:
        if file.content_type != "application/pdf":
            raise HTTPException(status_code=400, detail="Only PDF files allowed")
        
        content = await file.read()
        if len(content) > MAX_FILE_SIZE:
            raise HTTPException(status_code=400, detail="File exceeds 10MB")
        
        # Save input to temp
        temp_input = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
        temp_input.write(content)
        temp_input.close()
        
        # Unlock PDF
        output_path = PdfToolbox.unlock_pdf(temp_input.name, password)
        if not output_path:
            raise HTTPException(status_code=401, detail="Wrong password or corrupted file")
        
        # Cleanup
        background_tasks.add_task(PdfToolbox.cleanup_files, temp_input.name)
        background_tasks.add_task(PdfToolbox.cleanup_files, output_path)
        
        # Log activity
        if user_id:
            user_id_int = int(user_id)
            await log_activity(user_id_int, "pdf_tools", "unlock", {})
        
        return FileResponse(
            path=output_path,
            media_type="application/pdf",
            filename="unlocked.pdf"
        )
        
    except Exception as e:
        if temp_input:
            PdfToolbox.cleanup_files(temp_input.name)
        raise HTTPException(status_code=500, detail=str(e))
